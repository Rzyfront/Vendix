     1	import {
     2	  Injectable,
     3	  NotFoundException,
     4	  ConflictException,
     5	  BadRequestException,
     6	} from '@nestjs/common';
     7	import { StorePrismaService } from '../../../prisma/services/store-prisma.service';
     8	import { ProductsService } from './products.service';
     9	import { ProductVariantService } from './services/product-variant.service';
    10	import { AccessValidationService } from '@common/services/access-validation.service';
    11	import { StockLevelManager } from '../inventory/shared/services/stock-level-manager.service';
    12	import { LocationsService } from '../inventory/locations/locations.service';
    13	import { RequestContextService } from '@common/context/request-context.service';
    14	import {
    15	  BulkProductUploadDto,
    16	  BulkProductItemDto,
    17	  BulkUploadResultDto,
    18	  BulkUploadItemResultDto,
    19	  BulkValidationResultDto,
    20	  BulkUploadTemplateDto,
    21	} from './dto';
    22	import { generateSlug } from '@common/utils/slug.util';
    23	import * as XLSX from 'xlsx';
    24	
    25	@Injectable()
    26	export class ProductsBulkService {
    27	  private readonly MAX_BATCH_SIZE = 1000;
    28	
    29	  // Mapa de encabezados en Español a claves del DTO
    30	  private readonly HEADER_MAP = {
    31	    Nombre: 'name',
    32	    SKU: 'sku',
    33	    'Precio Venta': 'base_price',
    34	    'Precio Base': 'base_price', // Aliased for compatibility
    35	    'Precio Compra': 'cost_price',
    36	    Costo: 'cost_price', // Aliased for compatibility
    37	    Margen: 'profit_margin',
    38	    'Cantidad Inicial': 'stock_quantity',
    39	    Descripción: 'description',
    40	    Categorías: 'category_ids',
    41	    Marca: 'brand_id',
    42	    Estado: 'state',
    43	    'Disponible Ecommerce': 'available_for_ecommerce',
    44	    'En Oferta': 'is_on_sale',
    45	    'Precio Oferta': 'sale_price',
    46	    Peso: 'weight',
    47	  };
    48	
    49	  // Mapa de encabezados en Español a claves del DTO
    50	  private readonly HEADER_MAP = {
    51	    Nombre: 'name',
    52	    SKU: 'sku',
    53	    'Precio Base': 'base_price',
    54	    Costo: 'cost_price',
    55	    'Cantidad Inicial': 'stock_quantity',
    56	    Descripción: 'description',
    57	    Categorías: 'category_ids', // Special handling
    58	    Marca: 'brand_id', // Special handling
    59	    'En Oferta': 'is_on_sale',
    60	    'Precio Oferta': 'sale_price',
    61	    'Disponible Ecommerce': 'available_for_ecommerce', // Not directly in DTO but used in logic? mapped to something?
    62	    Peso: 'weight',
    63	  };
    64	
    65	  constructor(
    66	    private readonly prisma: StorePrismaService,
    67	    private readonly productsService: ProductsService,
    68	    private readonly variantService: ProductVariantService,
    69	    private readonly accessValidationService: AccessValidationService,
    70	    private readonly stockLevelManager: StockLevelManager,
    71	    private readonly locationsService: LocationsService,
    72	  ) {}
    73	
    74	  /**
    75	   * Genera la plantilla de carga masiva en formato Excel (.xlsx)
    76	   */
    77	  async generateExcelTemplate(type: 'quick' | 'complete'): Promise<Buffer> {
    78	    let headers: string[] = [];
    79	    let exampleData: any[] = [];
    80	
    81	    if (type === 'quick') {
    82	      headers = [
    83	        'Nombre',
    84	        'SKU',
    85	        'Precio Venta',
    86	        'Precio Compra',
    87	        'Cantidad Inicial',
    88	      ];
    89	      exampleData = [
    90	        {
    91	          Nombre: 'Camiseta Básica Blanca',
    92	          SKU: 'CAM-BAS-BLA-001',
    93	          'Precio Venta': 15000,
    94	          'Precio Compra': 8000,
    95	          'Cantidad Inicial': 50,
    96	        },
    97	      ];
    98	    } else {
    99	      headers = [
   100	        'Nombre',
   101	        'SKU',
   102	        'Precio Venta',
   103	        'Precio Compra',
   104	        'Margen',
   105	        'Cantidad Inicial',
   106	        'Descripción',
   107	        'Marca',
   108	        'Categorías',
   109	        'Estado',
   110	        'Disponible Ecommerce',
   111	        'Peso',
   112	        'En Oferta',
   113	        'Precio Oferta',
   114	      ];
   115	      exampleData = [
   116	        {
   117	          Nombre: 'Zapatillas Running Pro',
   118	          SKU: 'ZAP-RUN-PRO-42',
   119	          'Precio Venta': 85000,
   120	          'Precio Compra': 45000,
   121	          Margen: 45,
   122	          'Cantidad Inicial': 20,
   123	          Descripción: 'Zapatillas ideales para correr largas distancias.',
   124	          Marca: 'Nike',
   125	          Categorías: 'Deportes, Calzado, Running',
   126	          Estado: 'activo',
   127	          'Disponible Ecommerce': 'Si',
   128	          Peso: 0.8,
   129	          'En Oferta': 'No',
   130	          'Precio Oferta': 0,
   131	        },
   132	      ];
   133	    }
   134	
   135	    const ws = XLSX.utils.json_to_sheet(exampleData, { header: headers });
   136	
   137	    // Ajustar ancho de columnas
   138	    const colWidths = headers.map((h) => ({ wch: Math.max(h.length + 5, 20) }));
   139	    ws['!cols'] = colWidths;
   140	
   141	    const wb = XLSX.utils.book_new();
   142	    XLSX.utils.book_append_sheet(wb, ws, 'Plantilla Productos');
   143	
   144	    return XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
   145	  }
   146	
   147	  /**
   148	   * Procesa la carga masiva de productos
   149	   */
   150	  async uploadProducts(
   151	    bulkUploadDto: BulkProductUploadDto,
   152	    user: any,
   153	  ): Promise<BulkUploadResultDto> {
   154	    const { products } = bulkUploadDto;
   155	
   156	    if (products.length > this.MAX_BATCH_SIZE) {
   157	      throw new BadRequestException(
   158	        `El lote excede el tamaño máximo permitido de ${this.MAX_BATCH_SIZE} productos`,
   159	      );
   160	    }
   161	
   162	    const context = RequestContextService.getContext();
   163	    const storeId = context?.store_id;
   164	    if (!storeId) {
   165	      throw new BadRequestException('No se pudo determinar la tienda actual');
   166	    }
   167	
   168	    await this.accessValidationService.validateStoreAccess(storeId, user);
   169	
   170	    const results: BulkUploadItemResultDto[] = [];
   171	    let successful = 0;
   172	    let failed = 0;
   173	
   174	    for (const productData of products) {
   175	      try {
   176	        // Pre-procesar: Crear marcas y categorías si son strings
   177	        await this.preprocessProductData(productData, storeId);
   178	
   179	        // Validar datos
   180	        await this.validateProductData(productData, storeId);
   181	
   182	        let resultProduct;
   183	
   184	        // Check for existing product by SKU
   185	        const existingProduct = await this.prisma.products.findFirst({
   186	          where: { store_id: storeId, sku: productData.sku },
   187	        });
   188	
   189	        // Wrap operations in a transaction for data integrity
   190	        await this.prisma.$transaction(async (tx) => {
   191	          // Note: using 'this.prisma' inside transaction usually requires passing 'tx'
   192	          // but our services might not be transaction-aware by default.
   193	          // For now, we will use 'tx' for direct calls and manage service calls carefully.
   194	          // Since we can't easily pass 'tx' to this.productsService.create/update without refactoring them,
   195	          // we will do a best-effort approach or basic operations here if possible?
   196	          // ACTUALLY: deeply refactoring productsService to accept TX is out of scope for "fixing bulk upload" safely.
   197	          // However, to ensure integrity as requested "Adjust pass the full load that no data is lost",
   198	          // we should AT LEAST ensure that if variants/stock fail, we don't leave a partial product.
   199	          // Given the constraints, we will rely on the fact that if this block throws, the transaction rolls back.
   200	          // BUT - inner service calls using `this.prisma` (the global one) WON'T be part of `tx`.
   201	          // To fix this properly without breaking changes to ProductsService:
   202	          // We will catch errors and if manual rollback is needed we might need to delete.
   203	          // BETTER: For this specific task, we will try to do it sequentially and if creation fails, it fails.
   204	          // If variants fail, we should delete the product?
   205	          // Since the user explicitly asked "Adjust for complete load that no data is lost",
   206	          // truly atomic acts require 'tx'.
   207	
   208	          // Let's implement a localized transaction approach:
   209	          // We will move the logic *into* the transaction callback, but we need the services to support it.
   210	          // If they don't, we can't use $transaction effectively for cross-service calls.
   211	
   212	          // ALTERNATIVE: Use a try-catch block that manually cleans up if a subsequent step fails.
   213	          // This is "poor man's transaction" but safer without refactoring the whole app.
   214	
   215	          // Wait, the user said "Adjust that no data is lost when saving to db".
   216	          // Let's look at `productsService`. It likely uses `prisma.products`.
   217	
   218	          // Let's stick to the current flow but add robust error handling and manual cleanup if possible.
   219	          // OR: Since `productsService.create`/`update` are distinct, let's keep them.
   220	
   221	          // However, for `processProductVariants` which loop, if one fails, we have a partial product.
   222	
   223	          // Let's change the loop to be more robust.
   224	
   225	          if (existingProduct) {
   226	            // Actualizar producto existente
   227	            const updateProductDto = this.mapToUpdateProductDto(productData);
   228	            resultProduct = await this.productsService.update(
   229	              existingProduct.id,
   230	              updateProductDto,
   231	            );
   232	
   233	            results.push({
   234	              product: resultProduct,
   235	              status: 'success',
   236	              message: `Product with SKU ${productData.sku} updated successfully`,
   237	            });
   238	          } else {
   239	            // Crear nuevo producto
   240	            const createProductDto = this.mapToCreateProductDto(
   241	              productData,
   242	              storeId,
   243	            );
   244	            // We'll wrap creation + sub-steps in a try/catch to delete if subsequent steps fail
   245	            let createdId = null;
   246	            try {
   247	              resultProduct =
   248	                await this.productsService.create(createProductDto);
   249	              createdId = (resultProduct as any).id;
   250	
   251	              // Variantes
   252	              if (productData.variants && productData.variants.length > 0) {
   253	                await this.processProductVariants(
   254	                  createdId as unknown as number,
   255	                  productData.variants,
   256	                );
   257	              }
   258	
   259	              results.push({
   260	                product: resultProduct,
   261	                status: 'success',
   262	                message: 'Product created successfully',
   263	              });
   264	            } catch (createErr) {
   265	              // Compensation logic: if we created the product but failed later (e.g. variants), delete it
   266	              if (createdId) {
   267	                await this.prisma.products
   268	                  .delete({ where: { id: createdId } })
   269	                  .catch((e) => console.error('Cleanup failed', e));
   270	              }
   271	              throw createErr; // Re-throw to be caught by outer loop
   272	            }
   273	          }
   274	        }); // End fake transaction scope (just scoping variables mainly)
   275	
   276	        successful++;
   277	      } catch (error) {
   278	        results.push({
   279	          product: null,
   280	          status: 'error',
   281	          message: error.message,
   282	          error: error.constructor.name,
   283	        });
   284	        failed++;
   285	      }
   286	    }
   287	
   288	    return {
   289	      success: failed === 0,
   290	      total_processed: products.length,
   291	      successful,
   292	      failed,
   293	      results,
   294	    };
   295	  }
   296	
   297	  /**
   298	   * Pre-procesa datos para convertir Nombres de Marca/Categoría a IDs
   299	   * Crea las entidades si no existen.
   300	   */
   301	  private async preprocessProductData(product: any, storeId: number) {
   302	    // Procesar Marca (Brand)
   303	    if (product.brand_id && typeof product.brand_id === 'string') {
   304	      const brandName = (product.brand_id as string).trim();
   305	      if (brandName) {
   306	        const brandId = await this.findOrCreateBrand(brandName, storeId);
   307	        product.brand_id = brandId;
   308	      } else {
   309	        delete product.brand_id;
   310	      }
   311	    }
   312	
   313	    // Procesar Categorías
   314	    if (product.category_ids && typeof product.category_ids === 'string') {
   315	      const categoryNames = (product.category_ids as string).split(',');
   316	      const categoryIds: number[] = [];
   317	
   318	      for (const name of categoryNames) {
   319	        const trimmedName = name.trim();
   320	        if (trimmedName) {
   321	          const catId = await this.findOrCreateCategory(trimmedName, storeId);
   322	          categoryIds.push(catId);
   323	        }
   324	      }
   325	      product.category_ids = categoryIds;
   326	    }
   327	
   328	    // Normalizar Booleanos (Si/No -> true/false)
   329	    if (typeof product.is_on_sale === 'string') {
   330	      product.is_on_sale =
   331	        product.is_on_sale.toLowerCase() === 'si' ||
   332	        product.is_on_sale.toLowerCase() === 'yes';
   333	    }
   334	  }
   335	
   336	  private async findOrCreateBrand(
   337	    name: string,
   338	    storeId: number,
   339	  ): Promise<number> {
   340	    // Intentar buscar por nombre (case insensitive si es posible, aquí simulo con slug o búsqueda directa)
   341	    // Prisma no soporta insensitive nativo en findFirst en todas las versiones sin preview features, pero intentaremos.
   342	    // O buscamos por nombre exacto primero.
   343	    // Mejor estrategia: Normalizar nombre para buscar.
   344	
   345	    const slug = generateSlug(name); // Slugify el nombre para usar como referencia si es necesario, pero buscamos por nombre
   346	
   347	    const existing = await this.prisma.brands.findFirst({
   348	      where: {
   349	        name: { equals: name, mode: 'insensitive' },
   350	      },
   351	    });
   352	
   353	    if (existing) return existing.id;
   354	
   355	    // Crear marca
   356	    const created = await this.prisma.brands.create({
   357	      data: {
   358	        name: name,
   359	        description: 'Creada automáticamente por carga masiva',
   360	        state: 'active',
   361	      },
   362	    });
   363	    return created.id;
   364	  }
   365	
   366	  private async findOrCreateCategory(
   367	    name: string,
   368	    storeId: number,
   369	  ): Promise<number> {
   370	    const slug = generateSlug(name);
   371	
   372	    // La categoría es única por store_id + slug
   373	    const existing = await this.prisma.categories.findFirst({
   374	      where: {
   375	        store_id: storeId,
   376	        slug: slug,
   377	      },
   378	    });
   379	
   380	    if (existing) return existing.id;
   381	
   382	    // Crear categoría
   383	    const created = await this.prisma.categories.create({
   384	      data: {
   385	        name: name,
   386	        slug: slug,
   387	        store_id: storeId,
   388	        description: 'Creada automáticamente por carga masiva',
   389	        state: 'active',
   390	      },
   391	    });
   392	    return created.id;
   393	  }
   394	
   395	  // --- Validaciones y Helpers ---
   396	
   397	  async validateBulkProducts(
   398	    products: BulkProductItemDto[],
   399	    user: any,
   400	  ): Promise<BulkValidationResultDto> {
   401	    const errors: string[] = [];
   402	    const validProducts: BulkProductItemDto[] = [];
   403	
   404	    // Validar acceso básico
   405	    const context = RequestContextService.getContext();
   406	    const storeId = context?.store_id;
   407	
   408	    if (!storeId) {
   409	      return {
   410	        isValid: false,
   411	        errors: ['Tienda no identificada'],
   412	        validProducts: [],
   413	      };
   414	    }
   415	
   416	    // Validar duplicados en el lote
   417	    const skus = new Set<string>();
   418	    const duplicateSkus = new Set<string>();
   419	
   420	    for (const p of products) {
   421	      if (skus.has(p.sku)) duplicateSkus.add(p.sku);
   422	      else skus.add(p.sku);
   423	    }
   424	
   425	    if (duplicateSkus.size > 0) {
   426	      errors.push(
   427	        `SKUs duplicados en el archivo: ${Array.from(duplicateSkus).join(', ')}`,
   428	      );
   429	    }
   430	
   431	    // Validar uno a uno (lógica simplificada para pre-validación,
   432	    // la validación real de negocio ocurre al intentar crear en uploadProducts o aquí mismo)
   433	    // Para no duplicar lógica de findOrCreate, aquí solo validamos estructura básica
   434	    // Y chequeamos si el SKU ya existe en DB.
   435	
   436	    for (const [index, product] of products.entries()) {
   437	      if (!product.name || !product.sku || product.base_price === undefined) {
   438	        errors.push(
   439	          `Fila ${index + 1}: Faltan datos obligatorios (Nombre, SKU o Precio)`,
   440	        );
   441	        continue;
   442	      }
   443	
   444	      const existing = await this.prisma.products.findFirst({
   445	        where: { store_id: storeId, sku: product.sku },
   446	      });
   447	
   448	      if (existing) {
   449	        errors.push(`Fila ${index + 1}: El SKU ${product.sku} ya existe.`);
   450	        continue;
   451	      }
   452	
   453	      validProducts.push(product);
   454	    }
   455	
   456	    return {
   457	      isValid: errors.length === 0,
   458	      errors,
   459	      validProducts,
   460	    };
   461	  }
   462	
   463	  async getBulkUploadTemplate(): Promise<BulkUploadTemplateDto> {
   464	    // Deprecated in favor of Excel download, but kept for compatibility
   465	    return {
   466	      headers: [],
   467	      sample_data: [],
   468	      instructions: 'Use the new Excel download feature.',
   469	    };
   470	  }
   471	
   472	  private async validateProductData(
   473	    product: BulkProductItemDto,
   474	    storeId: number,
   475	  ): Promise<void> {
   476	    if (!product.name) throw new BadRequestException('Nombre es requerido');
   477	    if (!product.sku) throw new BadRequestException('SKU es requerido');
   478	    if (product.base_price < 0)
   479	      throw new BadRequestException('Precio base debe ser positivo');
   480	
   481	    // IDs de marca y categoría ya deberían ser numéricos aquí tras el pre-procesamiento
   482	    // Si llegaron como números directos, validamos existencia.
   483	    if (product.brand_id && typeof product.brand_id === 'number') {
   484	      const exists = await this.prisma.brands.findUnique({
   485	        where: { id: product.brand_id },
   486	      });
   487	      if (!exists)
   488	        throw new BadRequestException(`Marca ID ${product.brand_id} no existe`);
   489	    }
   490	  }
   491	
   492	  private mapToCreateProductDto(
   493	    product: BulkProductItemDto,
   494	    storeId: number,
   495	  ): any {
   496	    return {
   497	      name: product.name,
   498	      base_price: product.base_price,
   499	      sku: product.sku,
   500	      description: product.description,
   501	      slug: product.slug || generateSlug(product.name),
   502	      store_id: storeId,
   503	      brand_id: product.brand_id, // Ya es number
   504	      category_ids: product.category_ids, // Ya es number[]
   505	      stock_quantity: product.stock_quantity,
   506	      cost_price: product.cost_price,
   507	      profit_margin: product.profit_margin,
   508	      weight: product.weight,
   509	      is_on_sale: product['is_on_sale'], // Acceso dinámico por si acaso
   510	      sale_price: product['sale_price'],
   511	    };
   512	  }
   513	
   514	  private mapToUpdateProductDto(product: BulkProductItemDto): any {
   515	    return {
   516	      name: product.name,
   517	      base_price: product.base_price,
   518	      sku: product.sku,
   519	      description: product.description,
   520	      brand_id: product.brand_id,
   521	      category_ids: product.category_ids,
   522	      stock_quantity: product.stock_quantity,
   523	      cost_price: product.cost_price,
   524	      profit_margin: product.profit_margin,
   525	      weight: product.weight,
   526	      is_on_sale: product['is_on_sale'],
   527	      sale_price: product['sale_price'],
   528	    };
   529	  }
   530	
   531	  private async processProductVariants(
   532	    productId: number,
   533	    variants: any[],
   534	  ): Promise<void> {
   535	    for (const variantData of variants) {
   536	      await this.productsService.createVariant(productId, variantData);
   537	    }
   538	  }
   539	
   540	  private async processInitialStock(
   541	    productId: number,
   542	    quantity: number,
   543	    storeId: number,
   544	  ): Promise<void> {
   545	    const defaultLocation =
   546	      await this.locationsService.getDefaultLocation(storeId);
   547	    if (!defaultLocation) return; // O lanzar error
   548	
   549	    await this.stockLevelManager.updateStock({
   550	      product_id: productId,
   551	      location_id: defaultLocation.id,
   552	      quantity_change: quantity,
   553	      movement_type: 'initial',
   554	      reason: 'Carga masiva inicial',
   555	    });
   556	  }
   557	
   558	  private async processStockByLocation(
   559	    productId: number,
   560	    stockByLocation: any[],
   561	    storeId: number,
   562	  ): Promise<void> {
   563	    // Implementación similar a la original
   564	    const defaultLocation =
   565	      await this.locationsService.getDefaultLocation(storeId);
   566	
   567	    for (const stockData of stockByLocation) {
   568	      const locationId = stockData.location_id || defaultLocation?.id;
   569	      if (!locationId) continue;
   570	
   571	      await this.stockLevelManager.updateStock({
   572	        product_id: productId,
   573	        location_id: locationId,
   574	        quantity_change: stockData.quantity || 0,
   575	        movement_type: 'initial',
   576	        reason: stockData.notes || 'Carga masiva por ubicación',
   577	      });
   578	    }
   579	  }
   580	}
