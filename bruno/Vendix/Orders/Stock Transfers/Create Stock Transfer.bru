meta {
  name: Create Stock Transfer
  type: http
  seq: 1
}

post {
  url: {{baseUrl}}/stock-transfers
  body: json {
    "fromLocationId": "{{fromLocationId}}",
    "toLocationId": "{{toLocationId}}",
    "expectedDate": "2025-01-20T10:00:00Z",
    "notes": "Transfer for inventory replenishment",
    "items": [
      {
        "productId": "{{productId}}",
        "quantity": 50,
        "notes": "Urgent transfer needed"
      },
      {
        "productId": "{{productId2}}",
        "quantity": 25,
        "notes": "Regular stock rotation"
      }
    ]
  }
  auth: inherit
}

headers {
  Content-Type: application/json
  Authorization: Bearer {{authToken}}
}

tests {
  test("Should create stock transfer successfully", function() {
    expect(res.getStatus()).to.equal(201);
    
    const body = res.getBody();
    expect(body).to.be.an('object');
    
    // Validate basic structure
    expect(body).to.have.property('id');
    expect(body).to.have.property('transferNumber');
    expect(body).to.have.property('fromLocationId');
    expect(body).to.have.property('toLocationId');
    expect(body).to.have.property('status');
    expect(body).to.have.property('expectedDate');
    expect(body).to.have.property('notes');
    expect(body).to.have.property('createdAt');
    expect(body).to.have.property('updatedAt');
    
    // Validate status enum
    const validStatuses = ['PENDING', 'IN_TRANSIT', 'COMPLETED', 'CANCELLED'];
    expect(validStatuses).to.include(body.status);
    expect(body.status).to.equal('PENDING');
    
    // Validate data types
    expect(body.transferNumber).to.be.a('string');
    expect(body.fromLocationId).to.be.a('string');
    expect(body.toLocationId).to.be.a('string');
    expect(body.expectedDate).to.be.a('string');
    expect(body.notes).to.be.a('string');
    
    // Validate transfer number format
    expect(body.transferNumber).to.match(/^TRF-\d{4}-\d{3}$/);
    
    // Validate date format
    expect(new Date(body.expectedDate)).to.be.a('date');
    
    // Validate nested objects
    expect(body).to.have.property('fromLocation');
    expect(body).to.have.property('toLocation');
    expect(body).to.have.property('items');
    
    // Validate from location structure
    const fromLocation = body.fromLocation;
    expect(fromLocation).to.have.property('id');
    expect(fromLocation).to.have.property('name');
    expect(fromLocation).to.have.property('type');
    expect(fromLocation).to.have.property('address');
    expect(fromLocation).to.have.property('isActive');
    
    // Validate to location structure
    const toLocation = body.toLocation;
    expect(toLocation).to.have.property('id');
    expect(toLocation).to.have.property('name');
    expect(toLocation).to.have.property('type');
    expect(toLocation).to.have.property('address');
    expect(toLocation).to.have.property('isActive');
    
    // Validate items array
    const items = body.items;
    expect(items).to.be.an('array');
    expect(items.length).to.be.at.least(1);
    
    items.forEach(item => {
      expect(item).to.have.property('id');
      expect(item).to.have.property('stockTransferId');
      expect(item).to.have.property('productId');
      expect(item).to.have.property('quantity');
      expect(item).to.have.property('notes');
      expect(item).to.have.property('product');
      
      // Validate product structure
      const product = item.product;
      expect(product).to.have.property('id');
      expect(product).to.have.property('name');
      expect(product).to.have.property('sku');
      expect(product).to.have.property('description');
      expect(product).to.have.property('price');
      expect(product).to.have.property('cost');
      expect(product).to.have.property('categoryId');
      expect(product).to.have.property('brandId');
      
      // Validate item data types
      expect(item.quantity).to.be.a('number');
      expect(item.quantity).to.be.at.least(1);
      expect(item.notes).to.be.a('string');
    });
    
    // Validate timestamps
    expect(new Date(body.createdAt)).to.be.a('date');
    expect(new Date(body.updatedAt)).to.be.a('date');
    expect(new Date(body.updatedAt)).to.be.at.least(new Date(body.createdAt));
    
    // Validate location IDs match request
    expect(body.fromLocationId).to.equal(JSON.parse(req.getBody()).fromLocationId);
    expect(body.toLocationId).to.equal(JSON.parse(req.getBody()).toLocationId);
  });
  
  test("Should validate request data structure", function() {
    const requestBody = JSON.parse(req.getBody());
    
    // Validate required fields
    expect(requestBody).to.have.property('fromLocationId');
    expect(requestBody).to.have.property('toLocationId');
    expect(requestBody).to.have.property('items');
    
    expect(requestBody.fromLocationId).to.be.a('string');
    expect(requestBody.toLocationId).to.be.a('string');
    expect(requestBody.items).to.be.an('array');
    expect(requestBody.items.length).to.be.at.least(1);
    
    // Validate optional fields
    if (requestBody.expectedDate) {
      expect(requestBody.expectedDate).to.be.a('string');
      expect(new Date(requestBody.expectedDate)).to.be.a('date');
    }
    
    if (requestBody.notes) {
      expect(requestBody.notes).to.be.a('string');
    }
    
    // Validate items structure
    requestBody.items.forEach(item => {
      expect(item).to.have.property('productId');
      expect(item).to.have.property('quantity');
      
      expect(item.productId).to.be.a('string');
      expect(item.quantity).to.be.a('number');
      expect(item.quantity).to.be.at.least(1);
      
      if (item.notes) {
        expect(item.notes).to.be.a('string');
      }
    });
    
    // Validate different locations
    expect(requestBody.fromLocationId).to.not.equal(requestBody.toLocationId);
  });
  
  test("Should handle invalid location IDs", function() {
    // This test would be run with invalid location IDs
    // Expected behavior: 400 status with appropriate error message
    if (res.getStatus() === 400) {
      const body = res.getBody();
      expect(body).to.have.property('message');
      expect(body.message).to.include('location') || expect(body.message).to.include('not found');
    }
  });
  
  test("Should handle insufficient inventory", function() {
    // This test would be run with quantities exceeding available stock
    // Expected behavior: 400 status with appropriate error message
    if (res.getStatus() === 400) {
      const body = res.getBody();
      expect(body).to.have.property('message');
      expect(body.message).to.include('inventory') || expect(body.message).to.include('stock');
    }
  });
  
  test("Should handle same source and destination", function() {
    // This test would be run with same fromLocationId and toLocationId
    // Expected behavior: 400 status with appropriate error message
    if (res.getStatus() === 400) {
      const body = res.getBody();
      expect(body).to.have.property('message');
      expect(body.message).to.include('location') || expect(body.message).to.include('different');
    }
  });
  
  test("Should validate response time", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}